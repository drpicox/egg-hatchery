{"version":3,"file":"egg-hatchery.umd.min.js","sources":["../src/newBreedEgg.js","../src/newTools.js","../src/normalizeEggs.js","../src/index.js"],"sourcesContent":["const { defineProperty } = Object;\n\nexport default () => {\n  let publicBreeds;\n  const breedEgg = (tools) => {\n    const { tool } = tools;\n\n    const breeds = Object.create(null);\n    const frozenBreeds = Object.freeze(Object.create(breeds));\n    const factories = Object.create(null);\n\n    function validateBreedContext() {\n      if (tools.isHatched())\n        throw new Error('breed a hatching breed fails when hatch is finished');\n    }\n\n    function validateBreedName(name) {\n      if (!name || typeof name !== 'string')\n        throw new Error(\n          `invalid breed name, expected the first argument to be a non-empty string but received \"${name}\"`\n        );\n    }\n\n    function validateBreedFactory(factory) {\n      if (typeof factory !== 'function')\n        throw new Error(\n          `invalid breed function, expected the second argument to be a function but received \"${factory}\"`\n        );\n    }\n\n    function breed(name, factory) {\n      validateBreedContext();\n      validateBreedName(name);\n      validateBreedFactory(factory);\n\n      const uberFactory = factories[name];\n      const breedFactory = () => {\n        if (!tools.isHatched())\n          throw new Error('breeds object cannot be used until eggs hatch');\n\n        defineProperty(breeds, name, { get: uberFactory, configurable: true });\n        const value = factory(frozenBreeds);\n        defineProperty(breeds, name, { value, configurable: true });\n\n        return value;\n      };\n\n      factories[name] = breedFactory;\n\n      defineProperty(breeds, name, {\n        get: breedFactory,\n        configurable: true,\n      });\n    }\n\n    tool('breed', breed);\n    publicBreeds = frozenBreeds;\n  };\n\n  const getBreeds = () => publicBreeds;\n  return [breedEgg, getBreeds];\n};\n","export default function newTools() {\n  const tools = Object.create(null);\n  let isHatched = false;\n\n  const checkIsHatched = () => {\n    if (isHatched)\n      throw new Error(\n        `invalid state exception, cannot use tools once the egg is hatched`\n      );\n  };\n\n  tools.tool = (name, value) => {\n    if (!name || typeof name !== 'string')\n      throw new Error(\n        `invalid tool name, expected the first argument to be a non-empty string but received \"${name}\"`\n      );\n\n    checkIsHatched();\n\n    if (typeof value === 'function') {\n      const fn = value;\n      value = (...args) => {\n        checkIsHatched();\n        fn(...args);\n      };\n    }\n\n    tools[name] = value;\n  };\n\n  tools.isHatched = () => isHatched;\n  const hatched = () => (isHatched = true);\n\n  const frozenTools = Object.freeze(Object.create(tools));\n  return [frozenTools, hatched];\n}\n","function normalizeEggs(...eggs) {\n  const eggsSet = new Set();\n\n  function addEggs(nextEggs) {\n    for (let i = 0; i < nextEggs.length; i++)\n      if (Array.isArray(nextEggs[i])) addEggs(nextEggs[i]);\n      else eggsSet.add(nextEggs[i]);\n  }\n\n  addEggs(eggs);\n\n  return [...eggsSet];\n}\n\nexport default normalizeEggs;\n","import newBreedEgg from './newBreedEgg';\nimport newTools from './newTools';\nimport normalizeEggs from './normalizeEggs';\n\nfunction validateEggs(eggs) {\n  for (let i = 0; i < eggs.length; i++)\n    if (typeof eggs[i] !== 'function')\n      throw new Error(\n        `received egg is not an egg, expected a function but received \"${eggs[i]}\"`\n      );\n}\n\nfunction hatchEggs(eggs, tools) {\n  for (let i = 0; i < eggs.length; i++) eggs[i](tools);\n}\n\nexport default function hatch(...eggs) {\n  const [tools, hatched] = newTools();\n  const [breedEgg, getBreeds] = newBreedEgg();\n  const uniqueEggs = normalizeEggs(breedEgg, eggs);\n\n  validateEggs(uniqueEggs);\n  hatchEggs(uniqueEggs, tools);\n\n  const breeds = getBreeds();\n  hatched();\n\n  return breeds;\n}\n"],"names":["defineProperty","Object","publicBreeds","tools","tool","breeds","create","frozenBreeds","freeze","factories","name","factory","isHatched","Error","validateBreedContext","validateBreedName","validateBreedFactory","uberFactory","breedFactory","get","configurable","value","newTools","checkIsHatched","fn","normalizeEggs","eggsSet","Set","addEggs","nextEggs","i","length","Array","isArray","add","eggs","validateEggs","hatchEggs","hatched","newBreedEgg","breedEgg","getBreeds","uniqueEggs"],"mappings":"sMAAQA,EAAmBC,OAAnBD,gCAGFE,QAyDG,CAxDU,SAACC,OACRC,EAASD,EAATC,KAEFC,EAASJ,OAAOK,OAAO,MACvBC,EAAeN,OAAOO,OAAOP,OAAOK,OAAOD,IAC3CI,EAAYR,OAAOK,OAAO,MA8ChCF,EAAK,SAzBL,SAAeM,EAAMC,kBAlBfR,EAAMS,YACR,MAAM,IAAIC,MAAM,uDAkBlBC,YAfyBJ,OACpBA,GAAwB,iBAATA,EAClB,MAAM,IAAIG,gGACkFH,OAa9FK,CAAkBL,YATUC,MACL,mBAAZA,EACT,MAAM,IAAIE,6FAC+EF,OAO3FK,CAAqBL,OAEfM,EAAcR,EAAUC,GACxBQ,EAAe,eACdf,EAAMS,YACT,MAAM,IAAIC,MAAM,iDAElBb,EAAeK,EAAQK,EAAM,CAAES,IAAKF,EAAaG,cAAc,QACzDC,EAAQV,EAAQJ,UACtBP,EAAeK,EAAQK,EAAM,CAAEW,MAAAA,EAAOD,cAAc,IAE7CC,GAGTZ,EAAUC,GAAQQ,EAElBlB,EAAeK,EAAQK,EAAM,CAC3BS,IAAKD,EACLE,cAAc,OAKlBlB,EAAeK,GAGC,kBAAML,KC3DX,SAASoB,QAChBnB,EAAQF,OAAOK,OAAO,MACxBM,GAAY,EAEVW,EAAiB,cACjBX,EACF,MAAM,IAAIC,mFAKdV,EAAMC,KAAO,SAACM,EAAMW,OACbX,GAAwB,iBAATA,EAClB,MAAM,IAAIG,+FACiFH,UAG7Fa,IAEqB,mBAAVF,EAAsB,KACzBG,EAAKH,EACXA,EAAQ,WACNE,IACAC,2BAIJrB,EAAMO,GAAQW,GAGhBlB,EAAMS,UAAY,kBAAMA,GAIjB,CADaX,OAAOO,OAAOP,OAAOK,OAAOH,IAFhC,kBAAOS,GAAY,IC/BrC,SAASa,QACDC,EAAU,IAAIC,aAEXC,EAAQC,OACV,IAAIC,EAAI,EAAGA,EAAID,EAASE,OAAQD,IAC/BE,MAAMC,QAAQJ,EAASC,IAAKF,EAAQC,EAASC,IAC5CJ,EAAQQ,IAAIL,EAASC,+BANNK,2BAAAA,yBASxBP,EAAQO,aAEGT,GCPb,SAASU,EAAaD,OACf,IAAIL,EAAI,EAAGA,EAAIK,EAAKJ,OAAQD,OACR,mBAAZK,EAAKL,GACd,MAAM,IAAIjB,uEACyDsB,EAAKL,QAI9E,SAASO,EAAUF,EAAMhC,OAClB,IAAI2B,EAAI,EAAGA,EAAIK,EAAKJ,OAAQD,IAAKK,EAAKL,GAAG3B,UAGjC,qBACYmB,IAAlBnB,OAAOmC,SACgBC,IAAvBC,OAAUC,0BAFcN,2BAAAA,sBAGzBO,EAAajB,EAAce,EAAUL,GAE3CC,EAAaM,GACbL,EAAUK,EAAYvC,OAEhBE,EAASoC,WACfH,IAEOjC"}